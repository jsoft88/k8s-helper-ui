import { UIComponentFactory, UIComponent2YamlDoc } from './utils';
import { Pipe, PipeTransform } from '@angular/core';
import { YamlDocument } from 'src/core/yaml-block';

/**
 * This class returns the categories available in the app.
 * A `basic` category, which is a set of predefined concepts (e.g. Pod, Service, StatefulSet)
 * and a `custom` category, where all components can be used as desired by the user, to come up
 * with custom concepts. Keep in mind that this could lead to a compiled concept which makes no
 * sense.
 */
export class UiComponents {
    private categories: Category[];

    constructor() {
        const categoryBasic = new Category();
        categoryBasic.setCategoryLabel('Basic');
        categoryBasic.setCategoryDescription('Find templates for commonly used k8s concepts such as definitions for pods, services, etc.');
        categoryBasic.setCategoryComponentWrappers(UIComponentFactory.getAllPredefined());

        const categoryCustom = new Category();
        categoryCustom.setCategoryLabel('Custom');
        categoryCustom.setCategoryDescription('Here you have the posibility to create the definitions yourself, with required components.');
        categoryCustom.setCategoryComponentWrappers(UIComponentFactory.getAllComponents());

        this.categories = [categoryBasic, categoryCustom];
    }

    getCategories(): Category[] {
        return this.categories;
    }
}

@Pipe({name: 'canvasGetCanvasId'})
export class CanvasGetCanvasIdPipe implements PipeTransform {
    transform(canvas: Canvas): number {
        return canvas.getCanvasId();
    }
}

/**
 * Class representing the canvas where the user can drag and drop category component wrappers.
 * Each canvas has an autogenerated id and a set of category component wrappers.
 */
export class Canvas {
    private id: number;
    private categoryComponentWrappers: CategoryComponentWrapper[];

    constructor() {
        this.id = new Date().getMilliseconds();
        this.categoryComponentWrappers = [];
    }

    /**
     * Adds a component wrapper to the canvas
     * @param componentWrapper category component wrapper to add to the canvas
     */
    addToCanvas(componentWrapper: CategoryComponentWrapper) {
        this.categoryComponentWrappers.push(componentWrapper);
    }

    /**
     * Removes a category component wrapper from canvas
     * @param componentWrapper category component wrapper to be removed
     */
    removeFromCanvas(componentWrapper: CategoryComponentWrapper) {
        this.categoryComponentWrappers = this.categoryComponentWrappers.filter(ccw => ccw.getLabel() !== componentWrapper.getLabel());
    }

    /**
     * returns the id of the canvas
     */
    getCanvasId(): number {
        return this.id;
    }

    /**
     * Get all of the category component wrappers in the canvas
     */
    getAllComponentsInCanvas(): CategoryComponentWrapper[] {
        return this.categoryComponentWrappers;
    }
}

/**
 * Class which manages all canvas in the application
 */
export class CanvasManager {
    private static canvas: Canvas[] = [];
    private static activeCanvas = -1;

    static addCanvas() {
        CanvasManager.activeCanvas = CanvasManager.canvas.push(new Canvas()) - 1;
    }

    static swithToCanvas(id: number): void | Error {
        CanvasManager.activeCanvas = CanvasManager.canvas.findIndex(c => c.getCanvasId() === id);
        if (CanvasManager.activeCanvas < 0) {
            throw new Error('No canvas has been created');
        }
    }

    static getActiveCanvas(): Canvas | Error {
        if (CanvasManager.activeCanvas < 0) {
            throw new Error('No canvas has been created');
        }

        return CanvasManager.canvas[CanvasManager.activeCanvas];
    }

    static removeCanvas(canvas: Canvas): boolean {
        const canvasIndex = CanvasManager.canvas.findIndex(cnv => cnv.getCanvasId() === canvas.getCanvasId());
        if (canvasIndex < 0) {
            return false;
        }

        CanvasManager.canvas = CanvasManager.canvas.slice(canvasIndex, canvasIndex + 1);
        return true;
    }
}

@Pipe({name: 'categoryGetLabel'})
export class CategoryGetLabelPipe implements PipeTransform {
    transform(category: Category): string {
        return category.getCategoryLabel();
    }
}

@Pipe({name: 'categoryGetDescription'})
export class CategoryGetDescriptionPipe implements PipeTransform {
    transform(category: Category): string {
        return category.getCategoryDescription();
    }
}

/**
 * This class represents categories.
 * For example, we can have `Basic` and `Custom` categories.
 * Inside the categories, we have categories components wrappers.
 * These wrappers provide a wrapper for grouping different category components, which
 * in turn, provides the possibility to have predefined templates and also
 * custom kubernetes concepts components. For example, a pod is a predefined template
 * which contains several individual components wrapped inside a category component wrapper.
 */
export class Category {
    private categoryLabel: string;
    private categoryDescription: string;
    private categoryComponentWrappers: CategoryComponentWrapper[];

    constructor() { }

    getCategoryComponentWrappers(): CategoryComponentWrapper[] {
        return this.categoryComponentWrappers;
    }

    getCategoryLabel(): string {
        return this.categoryLabel;
    }

    getCategoryDescription(): string {
        return this.categoryDescription;
    }

    setCategoryComponentWrappers(categoryComponentWrappers: CategoryComponentWrapper[]): void {
        this.categoryComponentWrappers = categoryComponentWrappers.slice();
    }

    setCategoryLabel(categoryLabel: string): void {
        this.categoryLabel = categoryLabel;
    }

    setCategoryDescription(categoryDescription: string): void {
        this.categoryDescription = categoryDescription;
    }
}

@Pipe({name: 'categoryComponentWrapperGetLabel'})
export class CategoryComponentWrapperGetLabelPipe implements PipeTransform {
    transform(categoryComponentWrapper: CategoryComponentWrapper): string {
        return categoryComponentWrapper.getLabel();
    }
}

@Pipe({name: 'categoryComponentWrapperGetDescription'})
export class CategoryComponentWrapperGetDescriptionPipe implements PipeTransform {
    transform(categoryComponentWrapper: CategoryComponentWrapper): string {
        return categoryComponentWrapper.getDescription();
    }
}

@Pipe({name: 'categoryComponentWrapperGetIcon'})
export class CategoryComponentWrapperGetIconPipe implements PipeTransform {
    // This is just an abstraction for metadata, so we are defining a key for the desired metadata
    transform(categoryComponentWrapper: CategoryComponentWrapper): string {
        return categoryComponentWrapper.getMetadata(CategoryComponentMetadataDef.ICON_METADATA);
    }
}

/**
 * this is a static class that acts as an Enum of metadata that can be provided
 * to the CategoryComponentWrapper. In our case, we only have one for the icon that
 * will be used in the UI for this wrapper.
 */
export class CategoryComponentMetadataDef {
    static ICON_METADATA = 'ICONMETADATA';
}

@Pipe({name: 'categoryComponentWrapperId'})
export class CategoryComponentWrapperIdPipe implements PipeTransform {
    transform(categoryComponentWrapper: CategoryComponentWrapper): string {
        return categoryComponentWrapper.getLabel().replace(' ', '');
    }
}

/**
 * As mentioned above, this class provides a wrapper for the components a category
 * can have. Because one component under a given category can be composed of several
 * components. For example, a Basic category, which provides templates and one of these
 * templates is a `Pod`, needs to have wrapped (at least) an Api, Kind, Specs, Metadata,
 * Container and Volume. On the other hand, a `Custom` category contains Api, Kind, Specs,
 * etc., as different components and each wrapper only contains a single CategoryComponent.
 * However, for keeping this class generic, we consider every category component as an array
 * but in this case an array of a single element.
 */
export class CategoryComponentWrapper {
    private label: string;
    private description: string;
    private categoryComponents: CategoryComponent[];
    private metadata: Map<string, string>;

    constructor() {
        this.categoryComponents = [];
        this.metadata = new Map();
    }

    setCategoryComponents(categoryComponents: CategoryComponent[]): void {
        this.categoryComponents = categoryComponents.slice();
    }

    setLabel(label: string): void {
        this.label = label;
    }

    setDescription(description: string): void {
        this.description = description;
    }

    getCategoryComponents(): CategoryComponent[] {
        return this.categoryComponents;
    }

    getLabel(): string {
        return this.label;
    }

    getDescription(): string {
        return this.description;
    }

    addMetadata(metadataKey: string, metadataValue: string): void {
        this.metadata.set(metadataKey, metadataValue);
    }

    getMetadata(metadataKey: string): string {
        if (this.metadata.has(metadataKey)) {
            return this.metadata.get(metadataKey);
        }

        return '';
    }
}

@Pipe({name: 'categoryComponentGetLabel'})
export class CategoryComponentGetLabelPipe implements PipeTransform {
    transform(categoryComponent: CategoryComponent): string {
        return categoryComponent.categoryComponentLabel;
    }
}

/**
 * This class represents components of a given category.
 * It can be a simple component, a nested component or an array of components.
 * Also, a category component contains a value set by the user for the specific
 * component.
 */
export class CategoryComponent {
    categoryComponentLabel: string;
    categoryComponentDescription: string;
    categoryComponents: CategoryComponent[];
    coreComponentID: string;
    categoryComponentValue?: string;

    constructor() {
        this.categoryComponents = [];
    }

    /**
     * Angular2-form-json is used for automatically generating a form for the category component,
     * where the user can input the values for the components.
     * @param rootComponent the root component from which we recursion to generate the json schema for the form
     * @param addRequired whether to append a required key for a the component.
     * @returns a json schema in string format
     */
    private static formSchemaHelper(rootComponent: CategoryComponent, addRequired = true): string {
        // simple component
        if (!rootComponent.categoryComponents || rootComponent.categoryComponents.length === 0) {
            return `"${ rootComponent.categoryComponentLabel }": { "type": "string" }`;
        } else if (rootComponent.categoryComponents.length === 1) {
            // nested object
            return ` "${ rootComponent.categoryComponentLabel }": { "type": "object", "properties": {`
                + CategoryComponent.formSchemaHelper(rootComponent.categoryComponents[0], false)
                + `} }`; // , "required": [ "${rootComponent.categoryComponentLabel}" ] }`;
        } else {
            // array
            const requiredLabels = [];
            let arrVals = ` "${ rootComponent.categoryComponentLabel }": { "type": "array", "items": { "type": "object", "properties": { `;
            for (const component of rootComponent.categoryComponents) {
                requiredLabels.push(`"${ component.categoryComponentLabel }"`);
                // arrVals = arrVals.concat(` {`);
                arrVals = arrVals.concat(CategoryComponent.formSchemaHelper(component, false));
                arrVals = arrVals.concat(' ,'); // end the array field definition
            }
            arrVals = arrVals.slice(0, arrVals.length - 1);
            arrVals = arrVals.concat(` } }, "required": [${ requiredLabels.join(', ') }] }`);
            return arrVals;
        }
    }

    /**
     * The method which initializes and finalizes the json schema being generated by the helper method `formSchemaHelper`
     * @param rootComponent root of the category component for which the json schema is being generated
     * @param prefix the prefix to which we append the json schema returned by the helper. Initially is should be empty.
     * @param addRequired whether to make the category component required
     * @deprecated level field not needed currently.
     */
    public static getFormSchema(rootComponent: CategoryComponent, prefix: string = '', addRequired = true, level = 0): string {
        let cpPrefix = prefix;
        if (cpPrefix === '') {
            cpPrefix = cpPrefix.concat('{ "schema": { "type": "object", "properties": {');
        }
        cpPrefix = cpPrefix.concat(CategoryComponent.formSchemaHelper(rootComponent, true));
        cpPrefix = cpPrefix.concat(' }'); // end properties with }
        if (addRequired) {
            // check if required needs to be added
            cpPrefix = cpPrefix.concat(`, "required": ["${ rootComponent.categoryComponentLabel }"]`);
        }
        cpPrefix = cpPrefix.concat(' } }');
        console.log(cpPrefix);
        return cpPrefix;
    }

    /**
     * This method is in charge of mapping the json schema values to the category component values
     * @param component category component which needs its value filled in.
     * @param jsonData the json data returned by angular2-form-json
     */
    public fillInData(component: CategoryComponent = this, jsonData: any) {
        if (!component.categoryComponents || component.categoryComponents.length === 0) {
            component.categoryComponentValue = jsonData[this.categoryComponentLabel];
        } else if (component.categoryComponents.length === 1) {
            this.fillInData(component.categoryComponents[0], jsonData);
        } else {
            for (const subComponent of component.categoryComponents) {
                this.fillInData(subComponent, jsonData);
            }
        }
    }

    /**
     * Map from category components to yaml document
     */
    public getUIDefinition2Yaml(): YamlDocument {
        const yamlDoc = new YamlDocument(2);
        yamlDoc.addEntry(UIComponent2YamlDoc.yamlEntryBuilder(this));

        return yamlDoc;
    }
}
